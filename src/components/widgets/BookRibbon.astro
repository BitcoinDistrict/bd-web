---
import type { Widget } from '~/types';
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Image from '~/components/common/Image.astro';
import { bookClubBooks } from '~/data/bookclub';
import { getCurrentBook } from '~/utils/bookclub';
import { Icon } from 'astro-icon/components';
import { findImage } from '~/utils/images';

export interface Props extends Widget {
  title?: string;
  subtitle?: string;
  tagline?: string;
  displayCount?: number;
}

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline = await Astro.slots.render('tagline'),
  displayCount = 7, // 7 on desktop, will be responsive
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

// Find the featured book using the consistent utility function
const featuredBook = getCurrentBook();

// Resolve all image paths to actual URLs for client-side use
const resolvedBooks = await Promise.all(
  bookClubBooks.map(async (book) => {
    const resolvedImage = await findImage(book.image);
    return {
      ...book,
      resolvedImageSrc: typeof resolvedImage === 'string' ? resolvedImage : resolvedImage?.src || book.image
    };
  })
);

// Create a shuffled array of all books for cycling
const allBooksShuffled = [...resolvedBooks].sort(() => 0.5 - Math.random());

// Find the featured book index in the shuffled array
const featuredBookIndex = allBooksShuffled.findIndex(book => book.title === featuredBook.title && book.author === featuredBook.author);

// If featured book isn't in the shuffled array (shouldn't happen), add it
if (featuredBookIndex === -1) {
  const resolvedFeatured = resolvedBooks.find(book => book.title === featuredBook.title && book.author === featuredBook.author);
  if (resolvedFeatured) {
    allBooksShuffled.unshift(resolvedFeatured);
  }
}

// Check for empty book list and provide fallback
const hasBooks = allBooksShuffled.length > 0;

  // Create initial display centered on featured book (desktop: 7, mobile will be handled by JS)
  const centerIndex = Math.floor(displayCount / 2);
  const displayBooks: Array<{ book: typeof allBooksShuffled[0]; isFeatured: boolean }> = [];

  // Use the most recent books by date for the display
  // Sort books by date, with null dates at the end
  const sortedBooks = [...allBooksShuffled].sort((a, b) => {
    if (!a.date) return 1;
    if (!b.date) return -1;
    return new Date(b.date).getTime() - new Date(a.date).getTime();
  });

  // Find the featured book in the sorted array
  const sortedFeaturedIndex = sortedBooks.findIndex(book => 
    book.title === featuredBook.title && book.author === featuredBook.author
  );

  // Use either the sorted books or the shuffled books based on presence of featured book
  const booksToUse = sortedFeaturedIndex !== -1 ? sortedBooks : allBooksShuffled;
  const effectiveFeaturedIndex = sortedFeaturedIndex !== -1 ? sortedFeaturedIndex : featuredBookIndex;

  for (let i = 0; i < displayCount; i++) {
    const bookIndex = (effectiveFeaturedIndex - centerIndex + i + booksToUse.length) % booksToUse.length;
    displayBooks.push({
      book: booksToUse[bookIndex],
      isFeatured: i === centerIndex
    });
  }
---

<WidgetWrapper id={id} isDark={isDark} containerClass={`max-w-7xl ${classes?.container ?? ''}`} bg={bg}>
  <div class="book-ribbon-container relative overflow-hidden">
    {hasBooks ? (
      <>
        <!-- Gradient overlays for fade effect -->
        <div class="absolute left-0 top-0 bottom-0 w-16 bg-gradient-to-r from-page to-transparent z-10 pointer-events-none"></div>
        <div class="absolute right-0 top-0 bottom-0 w-16 bg-gradient-to-l from-page to-transparent z-10 pointer-events-none"></div>
        
        <!-- Main ribbon -->
        <div class="book-ribbon flex items-center justify-center gap-4 py-8 px-8 transition-transform duration-500 ease-in-out">
          {displayBooks.map(({ book, isFeatured }, index) => (
            <div 
              class={`book-cover-wrapper transition-all duration-300 cursor-pointer hover:scale-105 ${
                isFeatured 
                  ? 'scale-110 z-20' 
                  : `scale-${Math.max(75, 95 - Math.abs(index - centerIndex) * 10)} opacity-${Math.max(70, 100 - Math.abs(index - centerIndex) * 15)} hover:opacity-100`
              }`}
              data-book-index={index}
              data-is-featured={isFeatured}
            >
              <div class={`relative overflow-hidden rounded-lg shadow-lg transition-shadow duration-300 ${
                isFeatured ? 'ring-2 ring-primary/20' : 'shadow-md hover:shadow-xl'
              }`}>
                <Image
                  src={book.image}
                  alt={`${book.title} by ${book.author}`}
                  width={isFeatured ? 200 : 140}
                  height={isFeatured ? 300 : 210}
                  class={`object-cover transition-transform duration-300 ${
                    isFeatured ? 'w-32 h-48 sm:w-40 sm:h-60 md:w-48 md:h-72' : 'w-20 h-30 sm:w-24 sm:h-36 md:w-32 md:h-48'
                  }`}
                  loading="eager"
                />
                {isFeatured && (
                  <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none"></div>
                )}
              </div>
            </div>
          ))}
        </div>
      </>
    ) : (
      <!-- Fallback UI when no books are available -->
      <div class="flex items-center justify-center py-16 px-8">
        <div class="text-center">
          <div class="text-gray-400 mb-4">
            <Icon name="tabler:book-off" class="w-16 h-16 mx-auto" />
          </div>
          <h3 class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">No books available</h3>
          <p class="text-sm text-gray-500 dark:text-gray-400">Check back later for book club selections.</p>
        </div>
      </div>
    )}
  </div>
</WidgetWrapper>

<!-- Pass book data to JavaScript -->
<script type="application/json" id="book-data" define:vars={{ allBooksShuffled, featuredBookIndex: featuredBookIndex === -1 ? 0 : featuredBookIndex, displayCount }}>
  {
    "allBooks": allBooksShuffled,
    "featuredBookIndex": featuredBookIndex,
    "displayCount": displayCount
  }
</script>

<script define:vars={{ allBooksShuffled, featuredBookIndex: featuredBookIndex === -1 ? 0 : featuredBookIndex, displayCount }}>
  // Set the book data on window for the main script to access
  window.bookRibbonData = {
    allBooks: allBooksShuffled,
    featuredBookIndex: featuredBookIndex,
    displayCount: displayCount
  };
</script>

<script>
  interface BookData {
    title: string;
    author: string;
    image: string;
    date: string | null;
    link: string;
    resolvedImageSrc?: string;
  }

  declare global {
    interface Window {
      bookRibbonData?: {
        allBooks: BookData[];
        featuredBookIndex: number;
        displayCount: number;
      };
    }
  }

  class BookRibbon {
    private container: HTMLElement | null;
    private ribbon: HTMLElement | null;
    private bookElements: HTMLElement[];
    private visibleElements: HTMLElement[];
    private centerIndex: number;
    private currentOffset: number = 0;
    private allBooks: BookData[] = [];
    private featuredBookIndex: number = 0;
    private displayCount: number = 7;
    private currentDisplayCount: number = 7;

    constructor() {
      this.container = document.querySelector('.book-ribbon-container');
      this.ribbon = document.querySelector('.book-ribbon');
      this.bookElements = Array.from(document.querySelectorAll('.book-cover-wrapper')) as HTMLElement[];
      this.visibleElements = this.bookElements;
      
      this.loadBookData();
      this.initializeEventListeners();
      this.initializeIntersectionObserver();
      this.initializeResizeListener();
      
      // Initialize display count and positioning after data is loaded
      this.updateDisplayCountForScreenSize();
      
      // Ensure book positions are updated after a short delay
      setTimeout(() => {
        this.updateBookPositions();
      }, 100);
      
      console.log('Initializing book ribbon with', this.allBooks.length, 'books');
    }

    // Helper method to center the featured book in the current display
    centerFeaturedBook() {
      // Find the current featured book's position
      const currentFeaturedIndex = this.visibleElements.findIndex(el => 
        el.dataset.isFeatured === 'true'
      );
      
      if (currentFeaturedIndex !== -1) {
        const targetCenter = this.centerIndex;
        const offsetNeeded = targetCenter - currentFeaturedIndex;
        this.currentOffset += offsetNeeded;
        
        console.log('Centering featured book:', {
          currentFeaturedIndex,
          targetCenter,
          offsetNeeded,
          newOffset: this.currentOffset
        });
      } else {
        // Fallback: reset offset based on original featured book index and display count
        const isMobile = this.currentDisplayCount === 5;
        if (isMobile) {
          // For mobile (5 books), center should be at index 2
          this.currentOffset = this.featuredBookIndex - 2;
        } else {
          // For desktop (7 books), center should be at index 3  
          this.currentOffset = this.featuredBookIndex - 3;
        }
        
        console.log('Using fallback centering:', {
          isMobile,
          featuredBookIndex: this.featuredBookIndex,
          centerIndex: this.centerIndex,
          newOffset: this.currentOffset
        });
      }
    }

    loadBookData() {
      // Load book data from the window object set by the define:vars script
      if (window.bookRibbonData) {
        try {
          const data = window.bookRibbonData;
          
          // Sort books by date (most recent first)
          const sortedBooks = [...(data.allBooks || [])].sort((a, b) => {
            if (!a.date) return 1;
            if (!b.date) return -1;
            return new Date(b.date).getTime() - new Date(a.date).getTime();
          });
          
          this.allBooks = sortedBooks;
          this.featuredBookIndex = data.featuredBookIndex || 0;
          this.displayCount = data.displayCount || 7;
          this.currentOffset = 0; // Start with featured book in center
          
          console.log('Loaded book data:', {
            totalBooks: this.allBooks.length,
            featuredBookIndex: this.featuredBookIndex,
            featuredBook: this.allBooks[this.featuredBookIndex]?.title,
            displayCount: this.displayCount
          });
        } catch (e) {
          console.error('Failed to load book data:', e);
          this.allBooks = [];
        }
      } else {
        console.error('Book data not found on window object');
      }
    }

    updateDisplayCountForScreenSize() {
      const isMobile = window.innerWidth < 768;
      const newDisplayCount = isMobile ? 5 : this.displayCount;
      
      // Get all book elements first
      this.bookElements = Array.from(document.querySelectorAll('.book-cover-wrapper'));
      
      // Update visibility of book elements based on screen size
      this.bookElements.forEach((el, index) => {
        if (index < newDisplayCount) {
          el.style.display = '';
          el.style.removeProperty('display');
        } else {
          el.style.display = 'none';
        }
      });
      
      // Update current display count and center index
      this.currentDisplayCount = newDisplayCount;
      this.centerIndex = Math.floor(newDisplayCount / 2);

      // Capture first N visible elements directly based on newDisplayCount
      this.visibleElements = this.bookElements.slice(0, newDisplayCount) as HTMLElement[];

      // Apply a specific offset for mobile view to fix positioning
      if (isMobile) {
        // For mobile (5 books), we need to adjust the offset to -1 to align the featured book correctly
        this.currentOffset = -1;
      } else {
        // For desktop (7 books), reset to 0 as the initial layout is correct
        this.currentOffset = 0;
      }
      
      console.log('Screen size update:', {
        isMobile,
        displayCount: newDisplayCount,
        centerIndex: this.centerIndex,
        currentOffset: this.currentOffset,
        visibleElements: this.bookElements.length
      });
      
      this.initializeBookClickListeners();
      if (this.allBooks.length > 0) {
        this.updateBookPositions();
      }
    }

    initializeBookClickListeners() {
      this.visibleElements.forEach((book, index) => {
        book.addEventListener('click', (e) => {
          e.preventDefault();
          if (index !== this.centerIndex) {
            this.slideToPosition(index);
          }
        });
      });
    }

    initializeResizeListener() {
      let resizeTimeout: NodeJS.Timeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          // Store current screen state to detect transitions
          const wasMobile = this.currentDisplayCount === 5;
          const isNowMobile = window.innerWidth < 768;
          
          // Only update if there's an actual transition between mobile/desktop
          if (wasMobile !== isNowMobile) {
            console.log('Screen transition detected:', { wasMobile, isNowMobile });
            this.updateDisplayCountForScreenSize();
            
            // Force reposition of books after screen size change
            setTimeout(() => {
              this.updateBookPositions();
            }, 50);
          }
        }, 250);
      });
    }

    initializeEventListeners() {
      // Initialize book click listeners
      this.initializeBookClickListeners();
      
      // Touch/swipe support
      this.initializeTouchEvents();
    }

    initializeTouchEvents() {
      if (!this.ribbon) return;

      let startX = 0;
      let isDragging = false;

      this.ribbon.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        isDragging = true;
      }, { passive: true });

      this.ribbon.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
      });

      this.ribbon.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        
        const endX = e.changedTouches[0].clientX;
        const deltaX = startX - endX;

        // Only trigger swipe if movement is significant
        if (Math.abs(deltaX) > 50) {
          if (deltaX > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }
        
        isDragging = false;
      });

      // Mouse drag support for desktop
      let mouseStartX = 0;
      let isMouseDragging = false;

      this.ribbon.addEventListener('mousedown', (e) => {
        mouseStartX = e.clientX;
        isMouseDragging = true;
        this.ribbon!.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isMouseDragging) return;
        e.preventDefault();
      });

      document.addEventListener('mouseup', (e) => {
        if (!isMouseDragging) return;
        
        const endX = e.clientX;
        const deltaX = mouseStartX - endX;

        if (Math.abs(deltaX) > 50) {
          if (deltaX > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }
        
        isMouseDragging = false;
        this.ribbon!.style.cursor = 'grab';
      });
    }

    slideToPosition(targetIndex: number) {
      const direction = targetIndex > this.centerIndex ? 1 : -1;
      const steps = Math.abs(targetIndex - this.centerIndex);
      
      for (let i = 0; i < steps; i++) {
        setTimeout(() => {
          if (direction > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }, i * 200);
      }
    }

    navigateLeft() {
      console.log('Navigate left - Old offset:', this.currentOffset);
      this.currentOffset--;
      console.log('Navigate left - New offset:', this.currentOffset);
      this.updateBookPositions();
    }

    navigateRight() {
      console.log('Navigate right - Old offset:', this.currentOffset);
      this.currentOffset++;
      console.log('Navigate right - New offset:', this.currentOffset);
      this.updateBookPositions();
    }
    
    // Helper to get the most recent books by date
    getMostRecentBooks(count: number): BookData[] {
      return [...this.allBooks]
        .sort((a, b) => {
          if (!a.date) return 1;
          if (!b.date) return -1;
          return new Date(b.date).getTime() - new Date(a.date).getTime();
        })
        .slice(0, count);
    }

    updateBookPositions() {
      if (this.allBooks.length === 0) {
        console.error('No books loaded for cycling');
        return;
      }

      console.log('Updating positions - Current offset:', this.currentOffset, 'Featured book index:', this.featuredBookIndex);

      // Work only with currently visible elements
      const elements = this.visibleElements.length > 0 ? this.visibleElements : this.bookElements;
      elements.forEach((bookEl, index) => {
        // Calculate which book should be displayed in this position
        // Start from featured book index, adjust by current offset, then position relative to center
        const baseIndex = this.featuredBookIndex + this.currentOffset;
        const positionOffset = index - this.centerIndex;
        const bookIndex = (baseIndex + positionOffset + this.allBooks.length * 100) % this.allBooks.length;
        const book = this.allBooks[bookIndex];
        
        console.log(`Position ${index}: Book index ${bookIndex}, Book: ${book?.title || 'undefined'}`);
        
        // Debug mobile positioning
        const isMobile = this.currentDisplayCount === 5;
        if (isMobile && index === this.centerIndex) {
          console.log('Mobile center position:', {
            centerIndex: this.centerIndex,
            bookIndex,
            bookTitle: book?.title,
            offset: this.currentOffset
          });
        }
        
        // Calculate visual properties based on distance from center
        const distanceFromCenter = Math.abs(index - this.centerIndex);
        const isFeatured = index === this.centerIndex;
        
        // Update the book content (image and alt text) with preloading
        const img = bookEl.querySelector('img');
        if (img && book) {
          const newSrc = book.resolvedImageSrc || book.image;
          console.log(`Updating image for position ${index} to: ${newSrc}`);
          
          // Preload image to prevent flickering
          const tempImg = new Image();
          tempImg.onload = () => {
            // Update the actual image only after the new one is loaded
            img.src = newSrc;
            img.alt = `${book.title} by ${book.author}`;
            img.style.opacity = '';
          };
          tempImg.onerror = () => {
            console.error(`Failed to load image: ${newSrc}`);
            img.style.opacity = '';
          };
          
          // Start loading and add visual feedback
          img.style.opacity = '0.7';
          tempImg.src = newSrc;
        } else {
          console.error(`Missing img element or book data for position ${index}`);
        }
        
        // Remove existing transform classes
        bookEl.classList.remove(
          'scale-50', 'scale-75', 'scale-90', 'scale-100', 'scale-110', 'scale-125',
          'opacity-40', 'opacity-60', 'opacity-75', 'opacity-85', 'opacity-100',
          'z-10', 'z-20', 'z-30'
        );
        
        // Apply new transform based on position
        if (isFeatured) {
          bookEl.classList.add('scale-110', 'opacity-100', 'z-20');
          bookEl.dataset.isFeatured = 'true';
          
          // Add special styling for featured book
          const shadowDiv = bookEl.querySelector('.absolute.inset-0');
          if (shadowDiv) {
            shadowDiv.classList.remove('hidden');
          }
        } else {
          let scale = 'scale-90';
          let opacity = 'opacity-85';
          let zIndex = 'z-10';
          
          if (distanceFromCenter === 1) {
            scale = 'scale-100';
            opacity = 'opacity-90';
          } else if (distanceFromCenter === 2) {
            scale = 'scale-90';
            opacity = 'opacity-75';
          } else if (distanceFromCenter >= 3) {
            scale = 'scale-75';
            opacity = 'opacity-60';
          }
          
          bookEl.classList.add(scale, opacity, zIndex);
          bookEl.dataset.isFeatured = 'false';
          
          // Hide shadow for non-featured books
          const shadowDiv = bookEl.querySelector('.absolute.inset-0');
          if (shadowDiv) {
            shadowDiv.classList.add('hidden');
          }
        }
      });
      
      // Add a visual feedback that something is happening
      this.ribbon?.classList.add('transform-gpu');
      setTimeout(() => {
        this.ribbon?.classList.remove('transform-gpu');
      }, 300);
    }

    initializeIntersectionObserver() {
      const options = {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const books = entry.target.querySelectorAll('.book-cover-wrapper');
            books.forEach((book, index) => {
              setTimeout(() => {
                book.classList.add('animate-fade-in');
              }, index * 100);
            });
          }
        });
      }, options);

      if (this.container) {
        observer.observe(this.container);
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new BookRibbon();
  });

  // Re-initialize after Astro page transitions
  document.addEventListener('astro:after-swap', () => {
    new BookRibbon();
  });
</script>

<style>
  .book-ribbon {
    perspective: 1000px;
    cursor: grab;
  }

  .book-ribbon:active {
    cursor: grabbing;
  }

  .book-cover-wrapper {
    transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
    transform-style: preserve-3d;
  }

  .book-cover-wrapper:not([data-is-featured="true"]) {
    filter: brightness(0.8) saturate(0.9);
  }

  .book-cover-wrapper[data-is-featured="true"] {
    filter: brightness(1.1) saturate(1.1);
  }

  .book-cover-wrapper:hover {
    filter: brightness(1.1) saturate(1.1) !important;
  }

  .nav-arrow {
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .nav-dot {
    cursor: pointer;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fade-in {
    animation: fade-in 0.6s ease-out forwards;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .book-cover-wrapper {
      margin: 0 -4px;
    }
    
    .book-ribbon {
      gap: 6px;
      padding: 16px 8px;
    }
    
    .nav-arrow {
      padding: 8px;
    }
    
    .nav-arrow .icon {
      width: 20px;
      height: 20px;
    }
  }

  @media (max-width: 640px) {
    .book-ribbon {
      gap: 4px;
      padding: 12px 4px;
    }
  }

  @media (max-width: 480px) {
    .book-cover-wrapper img {
      width: 64px !important;
      height: 96px !important;
    }
    
    .book-cover-wrapper[data-is-featured="true"] img {
      width: 96px !important;
      height: 144px !important;
    }
    
    .book-ribbon {
      gap: 2px;
      padding: 8px 2px;
    }
    
    .book-cover-wrapper {
      margin: 0 -2px;
    }
  }
</style>