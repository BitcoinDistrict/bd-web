---
import type { Widget } from '~/types';
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';
import Image from '~/components/common/Image.astro';
import { bookClubBooks } from '~/data/bookclub';
import { getCurrentBook } from '~/utils/bookclub';
import { Icon } from 'astro-icon/components';
import { findImage } from '~/utils/images';

export interface Props extends Widget {
  title?: string;
  subtitle?: string;
  tagline?: string;
  displayCount?: number;
}

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline = await Astro.slots.render('tagline'),
  displayCount = 7, // 7 on desktop, JS will adapt for mobile
  id,
  isDark = false,
  classes = {},
  bg = await Astro.slots.render('bg'),
} = Astro.props;

// Resolve images once on the server to avoid client-side swaps
const resolvedBooks = await Promise.all(
  bookClubBooks.map(async (book) => {
    const resolvedImage = await findImage(book.image);
    return {
      ...book,
      resolvedImage, // ImageMetadata | string | null
      resolvedImageSrc: typeof resolvedImage === 'string' ? resolvedImage : resolvedImage?.src || book.image,
    };
  })
);

// Canonical ordering: books with dates first (ascending by date), then undated
const booksWithDates = resolvedBooks
  .filter((b) => b.date)
  .sort((a, b) => new Date(a.date!).getTime() - new Date(b.date!).getTime());
const booksWithoutDates = resolvedBooks.filter((b) => !b.date);
const orderedBooks = [...booksWithDates, ...booksWithoutDates];

// Determine the featured book (next by date or last past)
const featuredBook = getCurrentBook();
let featuredIndex = orderedBooks.findIndex(
  (b) => b.title === featuredBook.title && b.author === featuredBook.author
);
if (featuredIndex === -1) {
  // Fallback: center on the most recent dated book, or first item
  featuredIndex = Math.max(booksWithDates.length - 1, 0);
}

// Prepare initial display window centered on featured book
const hasBooks = orderedBooks.length > 0;
const centerIndex = Math.floor(displayCount / 2);
const displayBooks: Array<{ book: typeof orderedBooks[0]; isFeatured: boolean }> = [];
for (let i = 0; i < displayCount && hasBooks; i++) {
  const bookIndex = (featuredIndex - centerIndex + i + orderedBooks.length) % orderedBooks.length;
  displayBooks.push({
    book: orderedBooks[bookIndex],
    isFeatured: i === centerIndex,
  });
}

// Prepare serializable client payload (avoid ImageMetadata)
const clientBooks = orderedBooks.map(({ title, author, image, date, link, resolvedImageSrc }) => ({
  title,
  author,
  image,
  date,
  link,
  resolvedImageSrc,
}));
const ribbonData = {
  allBooks: clientBooks,
  featuredBookIndex: featuredIndex,
  displayCount,
};
---

<WidgetWrapper id={id} isDark={isDark} containerClass={`max-w-7xl ${classes?.container ?? ''}`} bg={bg}>
  <div class="book-ribbon-container relative overflow-hidden">
    {hasBooks ? (
      <>
        <!-- Gradient overlays for fade effect -->
        <div class="absolute left-0 top-0 bottom-0 w-16 bg-gradient-to-r from-page to-transparent z-10 pointer-events-none"></div>
        <div class="absolute right-0 top-0 bottom-0 w-16 bg-gradient-to-l from-page to-transparent z-10 pointer-events-none"></div>
        
        <!-- Main ribbon -->
        <div class="book-ribbon flex items-center justify-center gap-4 py-8 px-8 transition-transform duration-500 ease-in-out">
          {displayBooks.map(({ book, isFeatured }, index) => (
            <div 
              class={`book-cover-wrapper transition-all duration-300 cursor-pointer hover:scale-105 ${
                isFeatured
                  ? 'scale-110 opacity-100 z-20'
                  : (() => {
                      const distance = Math.abs(index - centerIndex);
                      if (distance === 1) return 'scale-100 opacity-90 z-10';
                      if (distance === 2) return 'scale-90 opacity-75 z-10';
                      return 'scale-75 opacity-60 z-10';
                    })()
              }`}
              data-book-index={index}
              data-is-featured={isFeatured}
            >
              <div class={`relative overflow-hidden rounded-lg shadow-lg transition-shadow duration-300 ${
                isFeatured ? 'ring-2 ring-primary/20' : 'shadow-md hover:shadow-xl'
              }`}>
                <Image
                  src={book.resolvedImage ?? book.image}
                  alt={`${book.title} by ${book.author}`}
                  width={isFeatured ? 200 : 140}
                  height={isFeatured ? 300 : 210}
                  class={`object-cover transition-transform duration-300 ${
                    isFeatured ? 'w-32 h-48 sm:w-40 sm:h-60 md:w-48 md:h-72' : 'w-20 h-30 sm:w-24 sm:h-36 md:w-32 md:h-48'
                  }`}
                  loading="eager"
                />
                {isFeatured && (
                  <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none"></div>
                )}
              </div>
            </div>
          ))}
        </div>
      </>
    ) : (
      <!-- Fallback UI when no books are available -->
      <div class="flex items-center justify-center py-16 px-8">
        <div class="text-center">
          <div class="text-gray-400 mb-4">
            <Icon name="tabler:book-off" class="w-16 h-16 mx-auto" />
          </div>
          <h3 class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">No books available</h3>
          <p class="text-sm text-gray-500 dark:text-gray-400">Check back later for book club selections.</p>
        </div>
      </div>
    )}
  </div>
</WidgetWrapper>

<!-- Pass ordered book data to JavaScript (no resorting on client) -->
<script type="application/json" id="book-ribbon-data" set:html={JSON.stringify(ribbonData)}></script>

<script>
  interface BookData {
    title: string;
    author: string;
    image: string;
    date: string | null;
    link: string;
    resolvedImageSrc?: string;
  }

  declare global {
    interface Window {
    }
  }

  class BookRibbon {
    private container: HTMLElement | null;
    private ribbon: HTMLElement | null;
    private bookElements: HTMLElement[];
    private visibleElements: HTMLElement[];
    private centerIndex: number;
    private currentOffset: number = 0;
    private allBooks: BookData[] = [];
    private featuredBookIndex: number = 0;
    private displayCount: number = 7;
    private currentDisplayCount: number = 7;

    constructor() {
      this.container = document.querySelector('.book-ribbon-container');
      this.ribbon = document.querySelector('.book-ribbon');
      this.bookElements = Array.from(document.querySelectorAll('.book-cover-wrapper')) as HTMLElement[];
      this.visibleElements = this.bookElements;

      this.loadBookData();
      this.initializeEventListeners();
      this.initializeIntersectionObserver();
      this.initializeResizeListener();

      // Initialize display count and positioning after data is loaded
      this.updateDisplayCountForScreenSize();

      // Ensure initial positions are applied immediately
      this.updateBookPositions();
    }

    loadBookData() {
      // Load book data from embedded JSON
      try {
        const dataEl = document.getElementById('book-ribbon-data');
        const json = dataEl?.textContent || '{}';
        const data = JSON.parse(json) as {
          allBooks: BookData[];
          featuredBookIndex: number;
          displayCount: number;
        };

        this.allBooks = Array.isArray(data.allBooks) ? data.allBooks : [];
        this.featuredBookIndex = typeof data.featuredBookIndex === 'number' ? data.featuredBookIndex : 0;
        this.displayCount = typeof data.displayCount === 'number' ? data.displayCount : 7;
        this.currentOffset = 0; // Start with featured book in center
      } catch (e) {
        // Silently fail if data is not present (e.g., on other pages)
        this.allBooks = [];
      }
    }

    updateDisplayCountForScreenSize() {
      const isMobile = window.innerWidth < 768;
      const newDisplayCount = isMobile ? 5 : this.displayCount;

      // Get all book elements first
      this.bookElements = Array.from(document.querySelectorAll('.book-cover-wrapper'));

      // Update visibility of book elements based on screen size
      this.bookElements.forEach((el, index) => {
        if (index < newDisplayCount) {
          el.style.display = '';
          el.style.removeProperty('display');
        } else {
          el.style.display = 'none';
        }
      });

      // Update current display count and center index
      this.currentDisplayCount = newDisplayCount;
      this.centerIndex = Math.floor(newDisplayCount / 2);

      // Capture first N visible elements directly based on newDisplayCount
      this.visibleElements = this.bookElements.slice(0, newDisplayCount) as HTMLElement[];

      // Keep featured centered when the visible count changes.
      // On mobile, a +1 offset compensates for DOM reuse from the 7-wide SSR layout
      // so the featured book lands in the middle (index 2 of 5).
      this.currentOffset = isMobile ? 1 : 0;
      // Recalculate the element list for the new center positioning
      this.visibleElements = this.bookElements.slice(0, newDisplayCount) as HTMLElement[];
      // Immediately position books with the updated centerIndex/visibleElements
      this.updateBookPositions();

      this.initializeBookClickListeners();
      if (this.allBooks.length > 0) {
        this.updateBookPositions();
      }
    }

    initializeBookClickListeners() {
      this.visibleElements.forEach((book, index) => {
        book.addEventListener('click', (e) => {
          e.preventDefault();
          if (index !== this.centerIndex) {
            this.slideToPosition(index);
          }
        });
      });
    }

    initializeResizeListener() {
      let resizeTimeout: number | undefined;
      window.addEventListener('resize', () => {
        if (resizeTimeout) window.clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          // Store current screen state to detect transitions
          const wasMobile = this.currentDisplayCount === 5;
          const isNowMobile = window.innerWidth < 768;

          // Only update if there's an actual transition between mobile/desktop
          if (wasMobile !== isNowMobile) {
            this.updateDisplayCountForScreenSize();
            this.updateBookPositions();
          }
        }, 250);
      });
    }

    initializeEventListeners() {
      // Initialize book click listeners
      this.initializeBookClickListeners();

      // Touch/swipe support
      this.initializeTouchEvents();
    }

    initializeTouchEvents() {
      if (!this.ribbon) return;

      let startX = 0;
      let isDragging = false;

      this.ribbon.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        isDragging = true;
      }, { passive: true });

      this.ribbon.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
      });

      this.ribbon.addEventListener('touchend', (e) => {
        if (!isDragging) return;

        const endX = e.changedTouches[0].clientX;
        const deltaX = startX - endX;

        // Only trigger swipe if movement is significant
        if (Math.abs(deltaX) > 50) {
          if (deltaX > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }

        isDragging = false;
      });

      // Mouse drag support for desktop
      let mouseStartX = 0;
      let isMouseDragging = false;

      this.ribbon.addEventListener('mousedown', (e) => {
        mouseStartX = e.clientX;
        isMouseDragging = true;
        this.ribbon!.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isMouseDragging) return;
        e.preventDefault();
      });

      document.addEventListener('mouseup', (e) => {
        if (!isMouseDragging) return;

        const endX = e.clientX;
        const deltaX = mouseStartX - endX;

        if (Math.abs(deltaX) > 50) {
          if (deltaX > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }

        isMouseDragging = false;
        this.ribbon!.style.cursor = 'grab';
      });
    }

    slideToPosition(targetIndex: number) {
      const direction = targetIndex > this.centerIndex ? 1 : -1;
      const steps = Math.abs(targetIndex - this.centerIndex);

      for (let i = 0; i < steps; i++) {
        setTimeout(() => {
          if (direction > 0) {
            this.navigateRight();
          } else {
            this.navigateLeft();
          }
        }, i * 200);
      }
    }

    navigateLeft() {
      this.currentOffset--;
      this.updateBookPositions();
    }

    navigateRight() {
      this.currentOffset++;
      this.updateBookPositions();
    }
    
    // Helper to get the most recent books by date
    getMostRecentBooks(count: number): BookData[] {
      return [...this.allBooks]
        .sort((a, b) => {
          if (!a.date) return 1;
          if (!b.date) return -1;
          return new Date(b.date).getTime() - new Date(a.date).getTime();
        })
        .slice(0, count);
    }

    updateBookPositions() {
      if (this.allBooks.length === 0) return;

      // Work only with currently visible elements
      const elements = this.visibleElements.length > 0 ? this.visibleElements : this.bookElements;
      elements.forEach((bookEl, index) => {
        // Calculate which book should be displayed in this position
        // Start from featured book index, adjust by current offset, then position relative to center
        const baseIndex = this.featuredBookIndex + this.currentOffset;
        const positionOffset = index - this.centerIndex;
        const bookIndex = (baseIndex + positionOffset + this.allBooks.length * 100) % this.allBooks.length;
        const book = this.allBooks[bookIndex];

        // Calculate visual properties based on distance from center
        const distanceFromCenter = Math.abs(index - this.centerIndex);
        const isFeatured = index === this.centerIndex;

        // Update the book content (image and alt text) with preloading
        const img = bookEl.querySelector('img');
        if (img && book) {
          const newSrc = book.resolvedImageSrc || book.image;

          // Preload image to prevent flickering
          const tempImg = new Image();
          tempImg.onload = () => {
            // Update the actual image only after the new one is loaded
            img.src = newSrc;
            img.alt = `${book.title} by ${book.author}`;
            img.style.opacity = '';
          };
          tempImg.onerror = () => {
            console.error(`Failed to load image: ${newSrc}`);
            img.style.opacity = '';
          };

          // Start loading and add visual feedback
          img.style.opacity = '0.7';
          tempImg.src = newSrc;
        } else {
          console.error(`Missing img element or book data for position ${index}`);
        }

        // Remove existing transform classes
        bookEl.classList.remove(
          'scale-50', 'scale-75', 'scale-90', 'scale-100', 'scale-110', 'scale-125',
          'opacity-40', 'opacity-60', 'opacity-75', 'opacity-85', 'opacity-100',
          'z-10', 'z-20', 'z-30'
        );

        // Apply new transform based on position
        if (isFeatured) {
          bookEl.classList.add('scale-110', 'opacity-100', 'z-20');
          bookEl.dataset.isFeatured = 'true';

          // Add special styling for featured book
          const shadowDiv = bookEl.querySelector('.absolute.inset-0');
          if (shadowDiv) {
            shadowDiv.classList.remove('hidden');
          }
        } else {
          let scale = 'scale-90';
          let opacity = 'opacity-85';
          let zIndex = 'z-10';

          if (distanceFromCenter === 1) {
            scale = 'scale-100';
            opacity = 'opacity-90';
          } else if (distanceFromCenter === 2) {
            scale = 'scale-90';
            opacity = 'opacity-75';
          } else if (distanceFromCenter >= 3) {
            scale = 'scale-75';
            opacity = 'opacity-60';
          }

          bookEl.classList.add(scale, opacity, zIndex);
          bookEl.dataset.isFeatured = 'false';

          // Hide shadow for non-featured books
          const shadowDiv = bookEl.querySelector('.absolute.inset-0');
          if (shadowDiv) {
            shadowDiv.classList.add('hidden');
          }
        }
      });

      // Add a visual feedback that something is happening
      this.ribbon?.classList.add('transform-gpu');
      setTimeout(() => {
        this.ribbon?.classList.remove('transform-gpu');
      }, 300);
    }

    initializeIntersectionObserver() {
      const options = {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const books = entry.target.querySelectorAll('.book-cover-wrapper');
            books.forEach((book, index) => {
              setTimeout(() => {
                book.classList.add('animate-fade-in');
              }, index * 100);
            });
          }
        });
      }, options);

      if (this.container) {
        observer.observe(this.container);
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.book-ribbon-container') as HTMLElement | null;
    const dataEl = document.getElementById('book-ribbon-data');
    if (container && dataEl && container.dataset.ribbonInit !== 'true') {
      container.dataset.ribbonInit = 'true';
      new BookRibbon();
    }
  });

  // Re-initialize after Astro page transitions
  document.addEventListener('astro:after-swap', () => {
    const container = document.querySelector('.book-ribbon-container') as HTMLElement | null;
    const dataEl = document.getElementById('book-ribbon-data');
    if (container && dataEl && container.dataset.ribbonInit !== 'true') {
      container.dataset.ribbonInit = 'true';
      new BookRibbon();
    }
  });
</script>

<style>
  .book-ribbon {
    perspective: 1000px;
    cursor: grab;
  }

  .book-ribbon:active {
    cursor: grabbing;
  }

  .book-cover-wrapper {
    transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
    transform-style: preserve-3d;
  }

  .book-cover-wrapper:not([data-is-featured="true"]) {
    filter: brightness(0.8) saturate(0.9);
  }

  .book-cover-wrapper[data-is-featured="true"] {
    filter: brightness(1.1) saturate(1.1);
  }

  .book-cover-wrapper:hover {
    filter: brightness(1.1) saturate(1.1) !important;
  }

  .nav-arrow {
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .nav-dot {
    cursor: pointer;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-fade-in {
    animation: fade-in 0.6s ease-out forwards;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .book-cover-wrapper {
      margin: 0 -4px;
    }
    
    .book-ribbon {
      gap: 6px;
      padding: 16px 8px;
    }
    
    .nav-arrow {
      padding: 8px;
    }
    
    .nav-arrow .icon {
      width: 20px;
      height: 20px;
    }
  }

  @media (max-width: 640px) {
    .book-ribbon {
      gap: 4px;
      padding: 12px 4px;
    }
  }

  @media (max-width: 480px) {
    .book-cover-wrapper img {
      width: 64px !important;
      height: 96px !important;
    }
    
    .book-cover-wrapper[data-is-featured="true"] img {
      width: 96px !important;
      height: 144px !important;
    }
    
    .book-ribbon {
      gap: 2px;
      padding: 8px 2px;
    }
    
    .book-cover-wrapper {
      margin: 0 -2px;
    }
  }
</style>