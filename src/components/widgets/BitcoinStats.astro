---
// Bitcoin Stats Widget - Live data from CoinGecko API
import { Icon } from 'astro-icon/components';

interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`bitcoin-stats-widget ${className}`}>
  <!-- Mobile Layout: 2-column grid -->
  <div class="md:hidden grid grid-cols-2 gap-3 max-w-md mx-auto">
    <!-- Bitcoin Price Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:currency-bitcoin" class="w-5 h-5 text-orange-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-price-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Bitcoin Price
        </div>
        <div class="text-xs mt-1" id="price-change-mobile">
          <span class="price-change-indicator-mobile"></span>
        </div>
      </div>
    </div>

    <!-- Bitcoin Hashrate Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:cpu" class="w-5 h-5 text-blue-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-hashrate-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Network Hashrate
        </div>
      </div>
    </div>

    <!-- Halving Progress Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:hourglass" class="w-5 h-5 text-purple-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="halving-progress-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Until Halving
        </div>
        <div class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-1 mt-2">
          <div class="bg-purple-500 h-1 rounded-full transition-all duration-500" id="halving-bar-mobile" style="width: 0%"></div>
        </div>
      </div>
    </div>

    <!-- Bitcoin Dominance Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:chart-pie" class="w-5 h-5 text-green-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-dominance-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Bitcoin Dominance
        </div>
      </div>
    </div>
  </div>

  <!-- Desktop/Tablet Layout: 4-column grid -->
  <div class="hidden md:grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 max-w-6xl mx-auto">
    <!-- Bitcoin Price -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-orange-500">
        <Icon name="tabler:currency-bitcoin" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-price">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Bitcoin Price (USD)
      </div>
      <div class="text-xs mt-1" id="price-change">
        <span class="price-change-indicator"></span>
      </div>
    </div>

    <!-- Bitcoin Hashrate -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-blue-500">
        <Icon name="tabler:cpu" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-hashrate">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Network Hashrate
      </div>
    </div>

    <!-- Halving Progress -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-purple-500">
        <Icon name="tabler:hourglass" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="halving-progress">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Until Next Halving
      </div>
      <div class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-2 mt-3">
        <div class="bg-purple-500 h-2 rounded-full transition-all duration-500" id="halving-bar" style="width: 0%"></div>
      </div>
    </div>

    <!-- Bitcoin Dominance -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-green-500">
        <Icon name="tabler:chart-pie" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-dominance">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Bitcoin Dominance
      </div>
    </div>
  </div>
</div>

<script>
  class BitcoinStatsWidget {
    CACHE_DURATION;
    UPDATE_INTERVALS;
    isTabActive;
    updateTimer;
    retryAttempts;
    maxRetries;
    
    constructor() {
      // Cache configuration
      this.CACHE_DURATION = {
        price: 2 * 60 * 1000, // 2 minutes for price data (most volatile)
        hashrate: 10 * 60 * 1000, // 10 minutes for hashrate (changes slowly)
        halving: 60 * 60 * 1000, // 1 hour for halving data (very stable)
        dominance: 5 * 60 * 1000 // 5 minutes for dominance (moderate volatility)
      };
      
      this.UPDATE_INTERVALS = {
        active: 2 * 60 * 1000, // 2 minutes when tab is active
        inactive: 10 * 60 * 1000 // 10 minutes when tab is inactive
      };
      
      this.isTabActive = true;
      this.updateTimer = null;
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      
      this.setupVisibilityListener();
      this.init();
      this.startUpdating();
    }

    setupVisibilityListener() {
      document.addEventListener('visibilitychange', () => {
        this.isTabActive = !document.hidden;
        this.restartUpdateTimer();
      });
    }

    async init() {
      await this.updateStats();
    }

    async updateStats() {
      try {
        // Check cache first, only fetch what's needed - run updates in parallel
        const priceUpdate = this.shouldUpdate('price') ? this.updateBitcoinData() : Promise.resolve();
        const hashrateUpdate = this.shouldUpdate('hashrate') ? this.updateHashrate() : Promise.resolve();
        const halvingUpdate = this.shouldUpdate('halving') ? this.updateHalvingProgress() : Promise.resolve();
        
        // Execute all update tasks in parallel
        await Promise.all([priceUpdate, hashrateUpdate, halvingUpdate]);
        
        // Update UI with cached data if available
        this.updateUIFromCache();
      } catch (error) {
        console.error('Error updating Bitcoin stats:', error);
      }
    }

    shouldUpdate(dataType) {
      const cached = this.getCachedData(dataType);
      if (!cached) return true;
      
      const now = Date.now();
      const cacheAge = now - cached.timestamp;
      return cacheAge > this.CACHE_DURATION[dataType];
    }

    getCachedData(key) {
      try {
        const cached = localStorage.getItem(`bitcoin-stats-${key}`);
        return cached ? JSON.parse(cached) : null;
      } catch (error) {
        console.error('Error reading cache:', error);
        return null;
      }
    }

    setCachedData(key, data) {
      try {
        const cacheEntry = {
          data,
          timestamp: Date.now()
        };
        localStorage.setItem(`bitcoin-stats-${key}`, JSON.stringify(cacheEntry));
      } catch (error) {
        console.error('Error writing cache:', error);
      }
    }

    updateUIFromCache() {
      // Update UI with any available cached data
      const priceData = this.getCachedData('price');
      const dominanceData = this.getCachedData('dominance');
      const hashrateData = this.getCachedData('hashrate');
      const halvingData = this.getCachedData('halving');

      if (priceData) {
        this.updatePriceUI(priceData.data.price, priceData.data.change);
      }
      if (dominanceData) {
        this.updateDominanceUI(dominanceData.data.dominance);
      }
      if (hashrateData) {
        this.updateHashrateUI(hashrateData.data.hashrate);
      }
      if (halvingData) {
        this.updateHalvingUI(halvingData.data);
      }
    }

    async updateBitcoinData() {
      const cacheKey = 'bitcoin-data';
      try {
        // Consolidated API call for both price and dominance data
        const [priceResponse, globalResponse] = await Promise.all([
          this.fetchWithRetry('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true&include_market_cap=true'),
          this.fetchWithRetry('https://api.coingecko.com/api/v3/global')
        ]);
        
        const priceData = await priceResponse.json();
        const globalData = await globalResponse.json();
        
        const price = priceData.bitcoin.usd;
        const change = priceData.bitcoin.usd_24h_change;
        const dominance = globalData.data.market_cap_percentage.btc;
        
        // Cache the combined data
        this.setCachedData('price', { price, change });
        this.setCachedData('dominance', { dominance });
        
        // Update UI
        this.updatePriceUI(price, change);
        this.updateDominanceUI(dominance);
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateBitcoinData());
      }
    }

    updatePriceUI(price, change) {
      const formattedPrice = `$${price.toLocaleString()}`;
      
      // Update desktop elements
      const priceElement = document.getElementById('bitcoin-price');
      const changeElement = document.getElementById('price-change');
      
      // Update mobile elements
      const priceElementMobile = document.getElementById('bitcoin-price-mobile');
      const changeElementMobile = document.getElementById('price-change-mobile');
      
      if (priceElement) {
        priceElement.textContent = formattedPrice;
      }
      if (priceElementMobile) {
        priceElementMobile.textContent = formattedPrice;
      }
      
      if (changeElement) {
        const changeIndicator = changeElement.querySelector('.price-change-indicator');
        if (changeIndicator) {
          const isPositive = change >= 0;
          changeIndicator.textContent = `${isPositive ? '+' : ''}${change.toFixed(2)}% (24h)`;
          changeIndicator.className = `price-change-indicator ${isPositive ? 'text-green-500' : 'text-red-500'}`;
        }
      }
      
      if (changeElementMobile) {
        const changeIndicatorMobile = changeElementMobile.querySelector('.price-change-indicator-mobile');
        if (changeIndicatorMobile) {
          const isPositive = change >= 0;
          changeIndicatorMobile.textContent = `${isPositive ? '+' : ''}${change.toFixed(2)}%`;
          changeIndicatorMobile.className = `price-change-indicator-mobile ${isPositive ? 'text-green-500' : 'text-red-500'}`;
        }
      }
    }

    updateDominanceUI(dominance) {
      const formattedDominance = `${dominance.toFixed(1)}%`;
      
      // Update desktop element
      const dominanceElement = document.getElementById('bitcoin-dominance');
      // Update mobile element
      const dominanceElementMobile = document.getElementById('bitcoin-dominance-mobile');
      
      if (dominanceElement) {
        dominanceElement.textContent = formattedDominance;
      }
      if (dominanceElementMobile) {
        dominanceElementMobile.textContent = formattedDominance;
      }
    }

    async updateHashrate() {
      const cacheKey = 'hashrate';
      try {
        // Using blockchain.info API for hashrate data
        const response = await this.fetchWithRetry('https://blockchain.info/q/hashrate');
        const hashrateGH = await response.text();
        
        // Convert from GH/s to EH/s (Exahashes per second)
        const hashrateEH = (parseFloat(hashrateGH) / 1000000000).toFixed(0);
        const hashrate = `${hashrateEH} EH/s`;
        
        // Cache the data
        this.setCachedData('hashrate', { hashrate });
        
        // Update UI
        this.updateHashrateUI(hashrate);
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateHashrate());
      }
    }

    updateHashrateUI(hashrate) {
      // Update desktop element
      const hashrateElement = document.getElementById('bitcoin-hashrate');
      // Update mobile element
      const hashrateElementMobile = document.getElementById('bitcoin-hashrate-mobile');
      
      if (hashrateElement) {
        hashrateElement.textContent = hashrate;
      }
      if (hashrateElementMobile) {
        hashrateElementMobile.textContent = hashrate;
      }
    }

    async updateHalvingProgress() {
      const cacheKey = 'halving';
      try {
        // Get current block height from blockchain.info
        const response = await this.fetchWithRetry('https://blockchain.info/q/getblockcount');
        const currentBlock = parseInt(await response.text());
        
        // Calculate halving progress
        const blocksPerHalving = 210000;
        const lastHalvingBlock = Math.floor(currentBlock / blocksPerHalving) * blocksPerHalving;
        const nextHalvingBlock = lastHalvingBlock + blocksPerHalving;
        const blocksUntilHalving = nextHalvingBlock - currentBlock;
        const progressPercent = ((currentBlock - lastHalvingBlock) / blocksPerHalving) * 100;
        
        // Estimate time until halving (approximately 10 minutes per block)
        const minutesUntilHalving = blocksUntilHalving * 10;
        const daysUntilHalving = Math.floor(minutesUntilHalving / (60 * 24));
        
        let formattedProgress;
        if (daysUntilHalving > 365) {
          const years = Math.floor(daysUntilHalving / 365);
          const remainingDays = daysUntilHalving % 365;
          formattedProgress = `~${years}y ${remainingDays}d`;
        } else {
          formattedProgress = `~${daysUntilHalving} days`;
        }
        
        const halvingData = {
          progress: formattedProgress,
          progressPercent: Math.min(progressPercent, 100)
        };
        
        // Cache the data
        this.setCachedData('halving', halvingData);
        
        // Update UI
        this.updateHalvingUI(halvingData);
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateHalvingProgress());
      }
    }

    updateHalvingUI(halvingData) {
      // Update desktop elements
      const progressElement = document.getElementById('halving-progress');
      const progressBar = document.getElementById('halving-bar');
      
      // Update mobile elements
      const progressElementMobile = document.getElementById('halving-progress-mobile');
      const progressBarMobile = document.getElementById('halving-bar-mobile');
      
      if (progressElement) {
        progressElement.textContent = halvingData.progress;
      }
      if (progressElementMobile) {
        progressElementMobile.textContent = halvingData.progress;
      }
      
      const progressWidth = `${halvingData.progressPercent}%`;
      if (progressBar) {
        progressBar.style.width = progressWidth;
      }
      if (progressBarMobile) {
        progressBarMobile.style.width = progressWidth;
      }
    }

    async fetchWithRetry(url, options = {}) {
      const maxRetries = 3;
      let lastError;
      
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          // Create an AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          return response;
        } catch (error) {
          lastError = error;
          
          if (attempt < maxRetries - 1) {
            // Exponential backoff: 1s, 2s, 4s
            const delay = Math.pow(2, attempt) * 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      throw lastError;
    }

    async handleRetry(cacheKey, error, retryFunction) {
      const attempts = this.retryAttempts.get(cacheKey) || 0;
      
      if (attempts < this.maxRetries) {
        this.retryAttempts.set(cacheKey, attempts + 1);
        console.warn(`Retrying ${cacheKey} (attempt ${attempts + 1}):`, error.message);
        
        // Exponential backoff
        const delay = Math.pow(2, attempts) * 1000;
        setTimeout(() => retryFunction(), delay);
      } else {
        console.error(`Failed to update ${cacheKey} after ${this.maxRetries} attempts:`, error);
        this.showErrorState(cacheKey);
      }
    }

    showErrorState(dataType) {
      const errorText = 'Error';
      
      switch (dataType) {
        case 'bitcoin-data':
          // Handle both price and dominance errors
          const priceElement = document.getElementById('bitcoin-price');
          const priceElementMobile = document.getElementById('bitcoin-price-mobile');
          const dominanceElement = document.getElementById('bitcoin-dominance');
          const dominanceElementMobile = document.getElementById('bitcoin-dominance-mobile');
          
          if (priceElement) priceElement.textContent = errorText;
          if (priceElementMobile) priceElementMobile.textContent = errorText;
          if (dominanceElement) dominanceElement.textContent = errorText;
          if (dominanceElementMobile) dominanceElementMobile.textContent = errorText;
          break;
          
        case 'hashrate':
          const hashrateElement = document.getElementById('bitcoin-hashrate');
          const hashrateElementMobile = document.getElementById('bitcoin-hashrate-mobile');
          if (hashrateElement) hashrateElement.textContent = errorText;
          if (hashrateElementMobile) hashrateElementMobile.textContent = errorText;
          break;
          
        case 'halving':
          const progressElement = document.getElementById('halving-progress');
          const progressElementMobile = document.getElementById('halving-progress-mobile');
          if (progressElement) progressElement.textContent = errorText;
          if (progressElementMobile) progressElementMobile.textContent = errorText;
          break;
      }
    }

    startUpdating() {
      this.restartUpdateTimer();
    }

    restartUpdateTimer() {
      // Clear existing timer
      if (this.updateTimer) {
        clearInterval(this.updateTimer);
      }
      
      // Set interval based on tab visibility
      const interval = this.isTabActive 
        ? this.UPDATE_INTERVALS.active 
        : this.UPDATE_INTERVALS.inactive;
      
      this.updateTimer = setInterval(() => {
        this.updateStats();
      }, interval);
    }

    // Cleanup method for when component is destroyed
    destroy() {
      if (this.updateTimer) {
        clearInterval(this.updateTimer);
      }
      document.removeEventListener('visibilitychange', this.setupVisibilityListener);
    }
  }

  // Singleton pattern to prevent multiple instances
  let bitcoinStatsInstance;

  function initializeBitcoinStats() {
    if (!bitcoinStatsInstance) {
      bitcoinStatsInstance = new BitcoinStatsWidget();
    }
    return bitcoinStatsInstance;
  }

  // Initialize the widget when the page loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBitcoinStats);
  } else {
    initializeBitcoinStats();
  }

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (bitcoinStatsInstance) {
      bitcoinStatsInstance.destroy();
    }
  });
</script>

<style>
  .bitcoin-stats-widget {
    animation: fadeInUp 0.8s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .price-change-indicator,
  .price-change-indicator-mobile {
    font-weight: 600;
  }
</style>