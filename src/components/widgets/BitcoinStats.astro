---
// Bitcoin Stats Widget - Live data from CoinGecko API
import { Icon } from 'astro-icon/components';

interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`bitcoin-stats-widget ${className}`}>
  <!-- Mobile Layout: 2-column grid -->
  <div class="md:hidden grid grid-cols-2 gap-3 max-w-md mx-auto">
    <!-- Bitcoin Price Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:currency-bitcoin" class="w-5 h-5 text-orange-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-price-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Bitcoin Price
        </div>
        <div class="text-xs mt-1" id="price-change-mobile">
          <span class="price-change-indicator-mobile"></span>
        </div>
      </div>
    </div>

    <!-- Bitcoin Hashrate Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:cpu" class="w-5 h-5 text-blue-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-hashrate-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Network Hashrate
        </div>
      </div>
    </div>

    <!-- Halving Progress Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:hourglass" class="w-5 h-5 text-purple-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="halving-progress-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Until Halving
        </div>
        <div class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-1 mt-2">
          <div class="bg-purple-500 h-1 rounded-full transition-all duration-500" id="halving-bar-mobile" style="width: 0%"></div>
        </div>
      </div>
    </div>

    <!-- Bitcoin Dominance Card -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-3 border border-white/20 dark:border-gray-700/30">
      <div class="text-center">
        <div class="flex items-center justify-center mb-2">
          <Icon name="tabler:chart-pie" class="w-5 h-5 text-green-500" />
        </div>
        <div class="text-sm font-bold text-gray-900 dark:text-white" id="bitcoin-dominance-mobile">
          Loading...
        </div>
        <div class="text-xs font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
          Bitcoin Dominance
        </div>
      </div>
    </div>
  </div>

  <!-- Desktop/Tablet Layout: 4-column grid -->
  <div class="hidden md:grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 max-w-6xl mx-auto">
    <!-- Bitcoin Price -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-orange-500">
        <Icon name="tabler:currency-bitcoin" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-price">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Bitcoin Price (USD)
      </div>
      <div class="text-xs mt-1" id="price-change">
        <span class="price-change-indicator"></span>
      </div>
    </div>

    <!-- Bitcoin Hashrate -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-blue-500">
        <Icon name="tabler:cpu" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-hashrate">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Network Hashrate
      </div>
    </div>

    <!-- Halving Progress -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-purple-500">
        <Icon name="tabler:hourglass" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="halving-progress">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Until Next Halving
      </div>
      <div class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-2 mt-3">
        <div class="bg-purple-500 h-2 rounded-full transition-all duration-500" id="halving-bar" style="width: 0%"></div>
      </div>
    </div>

    <!-- Bitcoin Dominance -->
    <div class="bg-white/10 dark:bg-gray-800/20 backdrop-blur-sm rounded-lg p-6 text-center border border-white/20 dark:border-gray-700/30">
      <div class="flex items-center justify-center mx-auto mb-3 text-green-500">
        <Icon name="tabler:chart-pie" class="w-8 h-8" />
      </div>
      <div class="text-2xl font-bold text-gray-900 dark:text-white mb-1" id="bitcoin-dominance">
        Loading...
      </div>
      <div class="text-sm font-medium uppercase tracking-wide text-gray-600 dark:text-gray-400">
        Bitcoin Dominance
      </div>
    </div>
  </div>
</div>

<script is:inline>
  // Immediate paint from localStorage cache to avoid "Loading..." on SPA navigations
  function paintFromLocalCache() {
    try {
      const get = (key) => {
        const raw = localStorage.getItem(`bitcoin-stats-${key}`);
        return raw ? JSON.parse(raw).data : null;
      };
      const price = get('price');
      const dom = get('dominance');
      const hashrate = get('hashrate');
      const halving = get('halving');

      if (price) {
        const formatted = `$${Number(price.price).toLocaleString()}`;
        const el = document.getElementById('bitcoin-price');
        const elM = document.getElementById('bitcoin-price-mobile');
        if (el) el.textContent = formatted;
        if (elM) elM.textContent = formatted;
        const pc = document.getElementById('price-change');
        const pcM = document.getElementById('price-change-mobile');
        if (pc) {
          const span = pc.querySelector('.price-change-indicator');
          if (span) {
            const isPos = Number(price.change) >= 0;
            span.textContent = `${isPos ? '+' : ''}${Number(price.change).toFixed(2)}% (24h)`;
            span.className = `price-change-indicator ${isPos ? 'text-green-500' : 'text-red-500'}`;
          }
        }
        if (pcM) {
          const spanM = pcM.querySelector('.price-change-indicator-mobile');
          if (spanM) {
            const isPos = Number(price.change) >= 0;
            spanM.textContent = `${isPos ? '+' : ''}${Number(price.change).toFixed(2)}%`;
            spanM.className = `price-change-indicator-mobile ${isPos ? 'text-green-500' : 'text-red-500'}`;
          }
        }
      }

      if (dom) {
        const formattedDom = `${Number(dom.dominance).toFixed(1)}%`;
        const d = document.getElementById('bitcoin-dominance');
        const dM = document.getElementById('bitcoin-dominance-mobile');
        if (d) d.textContent = formattedDom;
        if (dM) dM.textContent = formattedDom;
      }

      if (hashrate) {
        const h = document.getElementById('bitcoin-hashrate');
        const hM = document.getElementById('bitcoin-hashrate-mobile');
        if (h) h.textContent = hashrate.hashrate;
        if (hM) hM.textContent = hashrate.hashrate;
      }

      if (halving) {
        const p = document.getElementById('halving-progress');
        const pM = document.getElementById('halving-progress-mobile');
        const bar = document.getElementById('halving-bar');
        const barM = document.getElementById('halving-bar-mobile');
        if (p) p.textContent = halving.progress;
        if (pM) pM.textContent = halving.progress;
        const w = `${Math.min(Number(halving.progressPercent) || 0, 100)}%`;
        if (bar) bar.style.width = w;
        if (barM) barM.style.width = w;
      }
    } catch (_) {
      // ignore paint errors
    }
  }

  // Paint at next frame to ensure DOM is ready after SPA swaps
  try { requestAnimationFrame(paintFromLocalCache); } catch (_) { paintFromLocalCache(); }
  class BitcoinStatsWidget {
    CACHE_DURATION;
    isTabActive;
    updateTimer;
    retryAttempts;
    maxRetries;
    visibilityHandler;
    onlineHandler;
    broadcastChannel;
    inFlight;
    instanceId;
    
    constructor() {
      // Cache configuration
      this.CACHE_DURATION = {
        price: 2 * 60 * 1000, // 2 minutes for price data (most volatile)
        hashrate: 10 * 60 * 1000, // 10 minutes for hashrate (changes slowly)
        halving: 60 * 60 * 1000, // 1 hour for halving data (very stable)
        dominance: 5 * 60 * 1000 // 5 minutes for dominance (moderate volatility)
      };
      
      this.isTabActive = !document.hidden;
      this.updateTimer = null;
      this.retryAttempts = new Map();
      this.maxRetries = 3;
      this.inFlight = new Set();
      this.instanceId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
      
      // BroadcastChannel for cross-tab/page dedupe + updates
      try {
        this.broadcastChannel = new BroadcastChannel('bitcoin-stats');
        this.broadcastChannel.onmessage = (event) => {
          const message = event?.data || {};
          if (message?.type === 'cache-update' && message?.key) {
            // Persist and update UI from broadcast data
            this.setCachedData(message.key, message.data);
            switch (message.key) {
              case 'price':
                this.updatePriceUI(message.data.price, message.data.change);
                break;
              case 'dominance':
                this.updateDominanceUI(message.data.dominance);
                break;
              case 'hashrate':
                this.updateHashrateUI(message.data.hashrate);
                break;
              case 'halving':
                this.updateHalvingUI(message.data);
                break;
            }
          }
        };
      } catch (_) {
        // BroadcastChannel not available; safely ignore
        this.broadcastChannel = null;
      }
      
      this.setupVisibilityListener();
      // Immediately paint from any existing cache
      this.updateUIFromCache();
      this.init();
      this.startUpdating();
    }

    setupVisibilityListener() {
      this.visibilityHandler = () => {
        this.isTabActive = !document.hidden;
        this.restartUpdateTimer(true);
      };
      document.addEventListener('visibilitychange', this.visibilityHandler);
      
      this.onlineHandler = () => {
        this.updateStats();
        this.restartUpdateTimer(true);
      };
      window.addEventListener('online', this.onlineHandler);
    }

    async init() {
      await this.updateStats();
    }

    async updateStats() {
      try {
        // Check cache first, only fetch what's needed - run updates in parallel
        const priceUpdate = this.shouldUpdate('price') ? this.updateBitcoinData() : Promise.resolve();
        const hashrateUpdate = this.shouldUpdate('hashrate') ? this.updateHashrate() : Promise.resolve();
        const halvingUpdate = this.shouldUpdate('halving') ? this.updateHalvingProgress() : Promise.resolve();
        
        // Execute all update tasks in parallel
        await Promise.all([priceUpdate, hashrateUpdate, halvingUpdate]);
        
        // Update UI with cached data if available
        this.updateUIFromCache();
      } catch (error) {
        console.error('Error updating Bitcoin stats:', error);
      }
    }

    shouldUpdate(dataType) {
      const cached = this.getCachedData(dataType);
      if (!cached) return true;
      
      const now = Date.now();
      const cacheAge = now - cached.timestamp;
      return cacheAge > this.getEffectiveCacheDuration(dataType);
    }

    getEffectiveCacheDuration(dataType) {
      // Scale cache duration when tab is inactive to reduce network traffic
      const multiplier = this.isTabActive ? 1 : 5; // inactive ≈ 5x longer TTL
      return (this.CACHE_DURATION[dataType] || (2 * 60 * 1000)) * multiplier;
    }

    getCachedData(key) {
      try {
        const cached = localStorage.getItem(`bitcoin-stats-${key}`);
        return cached ? JSON.parse(cached) : null;
      } catch (error) {
        console.error('Error reading cache:', error);
        return null;
      }
    }

    setCachedData(key, data) {
      try {
        const cacheEntry = {
          data,
          timestamp: Date.now()
        };
        localStorage.setItem(`bitcoin-stats-${key}`, JSON.stringify(cacheEntry));
      } catch (error) {
        console.error('Error writing cache:', error);
      }
    }

    updateUIFromCache() {
      // Update UI with any available cached data
      const priceData = this.getCachedData('price');
      const dominanceData = this.getCachedData('dominance');
      const hashrateData = this.getCachedData('hashrate');
      const halvingData = this.getCachedData('halving');

      if (priceData) {
        this.updatePriceUI(priceData.data.price, priceData.data.change);
      }
      if (dominanceData) {
        this.updateDominanceUI(dominanceData.data.dominance);
      }
      if (hashrateData) {
        this.updateHashrateUI(hashrateData.data.hashrate);
      }
      if (halvingData) {
        this.updateHalvingUI(halvingData.data);
      }
    }

    async updateBitcoinData() {
      const cacheKey = 'bitcoin-data';
      if (this.inFlight.has(cacheKey)) return;
      this.inFlight.add(cacheKey);
      try {
        // Consolidated API call for both price and dominance data
        const [priceResponse, globalResponse] = await Promise.all([
          this.fetchWithRetry('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true&include_market_cap=true'),
          this.fetchWithRetry('https://api.coingecko.com/api/v3/global')
        ]);
        
        const priceData = await priceResponse.json();
        const globalData = await globalResponse.json();
        
        const price = priceData.bitcoin.usd;
        const change = priceData.bitcoin.usd_24h_change;
        const dominance = globalData.data.market_cap_percentage.btc;
        
        // Cache the combined data
        this.setCachedData('price', { price, change });
        this.setCachedData('dominance', { dominance });
        
        // Update UI
        this.updatePriceUI(price, change);
        this.updateDominanceUI(dominance);

        // Broadcast to other tabs/pages
        this.broadcastChannel?.postMessage({ type: 'cache-update', key: 'price', data: { price, change } });
        this.broadcastChannel?.postMessage({ type: 'cache-update', key: 'dominance', data: { dominance } });
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateBitcoinData());
      } finally {
        this.inFlight.delete(cacheKey);
      }
    }

    updatePriceUI(price, change) {
      const formattedPrice = `$${price.toLocaleString()}`;
      
      // Update desktop elements
      const priceElement = document.getElementById('bitcoin-price');
      const changeElement = document.getElementById('price-change');
      
      // Update mobile elements
      const priceElementMobile = document.getElementById('bitcoin-price-mobile');
      const changeElementMobile = document.getElementById('price-change-mobile');
      
      if (priceElement) {
        priceElement.textContent = formattedPrice;
      }
      if (priceElementMobile) {
        priceElementMobile.textContent = formattedPrice;
      }
      
      if (changeElement) {
        const changeIndicator = changeElement.querySelector('.price-change-indicator');
        if (changeIndicator) {
          const isPositive = change >= 0;
          changeIndicator.textContent = `${isPositive ? '+' : ''}${change.toFixed(2)}% (24h)`;
          changeIndicator.className = `price-change-indicator ${isPositive ? 'text-green-500' : 'text-red-500'}`;
        }
      }
      
      if (changeElementMobile) {
        const changeIndicatorMobile = changeElementMobile.querySelector('.price-change-indicator-mobile');
        if (changeIndicatorMobile) {
          const isPositive = change >= 0;
          changeIndicatorMobile.textContent = `${isPositive ? '+' : ''}${change.toFixed(2)}%`;
          changeIndicatorMobile.className = `price-change-indicator-mobile ${isPositive ? 'text-green-500' : 'text-red-500'}`;
        }
      }
    }

    updateDominanceUI(dominance) {
      const formattedDominance = `${dominance.toFixed(1)}%`;
      
      // Update desktop element
      const dominanceElement = document.getElementById('bitcoin-dominance');
      // Update mobile element
      const dominanceElementMobile = document.getElementById('bitcoin-dominance-mobile');
      
      if (dominanceElement) {
        dominanceElement.textContent = formattedDominance;
      }
      if (dominanceElementMobile) {
        dominanceElementMobile.textContent = formattedDominance;
      }
    }

    async updateHashrate() {
      const cacheKey = 'hashrate';
      if (this.inFlight.has(cacheKey)) return;
      this.inFlight.add(cacheKey);
      try {
        // Using blockchain.info API for hashrate data
        const response = await this.fetchWithRetry('https://blockchain.info/q/hashrate');
        const hashrateGH = await response.text();
        
        // Convert from GH/s to EH/s (Exahashes per second)
        const hashrateEH = (parseFloat(hashrateGH) / 1000000000).toFixed(0);
        const hashrate = `${hashrateEH} EH/s`;
        
        // Cache the data
        this.setCachedData('hashrate', { hashrate });
        
        // Update UI
        this.updateHashrateUI(hashrate);

        // Broadcast to other tabs/pages
        this.broadcastChannel?.postMessage({ type: 'cache-update', key: 'hashrate', data: { hashrate } });
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateHashrate());
      } finally {
        this.inFlight.delete(cacheKey);
      }
    }

    updateHashrateUI(hashrate) {
      // Update desktop element
      const hashrateElement = document.getElementById('bitcoin-hashrate');
      // Update mobile element
      const hashrateElementMobile = document.getElementById('bitcoin-hashrate-mobile');
      
      if (hashrateElement) {
        hashrateElement.textContent = hashrate;
      }
      if (hashrateElementMobile) {
        hashrateElementMobile.textContent = hashrate;
      }
    }

    async updateHalvingProgress() {
      const cacheKey = 'halving';
      if (this.inFlight.has(cacheKey)) return;
      this.inFlight.add(cacheKey);
      try {
        // Get current block height from blockchain.info
        const response = await this.fetchWithRetry('https://blockchain.info/q/getblockcount');
        const currentBlock = parseInt(await response.text());
        
        // Calculate halving progress
        const blocksPerHalving = 210000;
        const lastHalvingBlock = Math.floor(currentBlock / blocksPerHalving) * blocksPerHalving;
        const nextHalvingBlock = lastHalvingBlock + blocksPerHalving;
        const blocksUntilHalving = nextHalvingBlock - currentBlock;
        const progressPercent = ((currentBlock - lastHalvingBlock) / blocksPerHalving) * 100;
        
        // Estimate time until halving (approximately 10 minutes per block)
        const minutesUntilHalving = blocksUntilHalving * 10;
        const daysUntilHalving = Math.floor(minutesUntilHalving / (60 * 24));
        
        let formattedProgress;
        if (daysUntilHalving > 365) {
          const years = Math.floor(daysUntilHalving / 365);
          const remainingDays = daysUntilHalving % 365;
          formattedProgress = `~${years}y ${remainingDays}d`;
        } else {
          formattedProgress = `~${daysUntilHalving} days`;
        }
        
        const halvingData = {
          progress: formattedProgress,
          progressPercent: Math.min(progressPercent, 100)
        };
        
        // Cache the data
        this.setCachedData('halving', halvingData);
        
        // Update UI
        this.updateHalvingUI(halvingData);

        // Broadcast to other tabs/pages
        this.broadcastChannel?.postMessage({ type: 'cache-update', key: 'halving', data: halvingData });
        
        // Reset retry counter on success
        this.retryAttempts.set(cacheKey, 0);
      } catch (error) {
        await this.handleRetry(cacheKey, error, () => this.updateHalvingProgress());
      } finally {
        this.inFlight.delete(cacheKey);
      }
    }

    updateHalvingUI(halvingData) {
      // Update desktop elements
      const progressElement = document.getElementById('halving-progress');
      const progressBar = document.getElementById('halving-bar');
      
      // Update mobile elements
      const progressElementMobile = document.getElementById('halving-progress-mobile');
      const progressBarMobile = document.getElementById('halving-bar-mobile');
      
      if (progressElement) {
        progressElement.textContent = halvingData.progress;
      }
      if (progressElementMobile) {
        progressElementMobile.textContent = halvingData.progress;
      }
      
      const progressWidth = `${halvingData.progressPercent}%`;
      if (progressBar) {
        progressBar.style.width = progressWidth;
      }
      if (progressBarMobile) {
        progressBarMobile.style.width = progressWidth;
      }
    }

    async fetchWithRetry(url, options = {}) {
      const maxRetries = 3;
      let lastError;
      
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          // Create an AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          return response;
        } catch (error) {
          lastError = error;
          
          if (attempt < maxRetries - 1) {
            // Exponential backoff: 1s, 2s, 4s
            const delay = Math.pow(2, attempt) * 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      throw lastError;
    }

    async handleRetry(cacheKey, error, retryFunction) {
      const attempts = this.retryAttempts.get(cacheKey) || 0;
      
      if (attempts < this.maxRetries) {
        this.retryAttempts.set(cacheKey, attempts + 1);
        console.warn(`Retrying ${cacheKey} (attempt ${attempts + 1}):`, error.message);
        
        // Exponential backoff
        const delay = Math.pow(2, attempts) * 1000;
        setTimeout(() => retryFunction(), delay);
      } else {
        console.error(`Failed to update ${cacheKey} after ${this.maxRetries} attempts:`, error);
        this.showErrorState(cacheKey);
      }
    }

    showErrorState(dataType) {
      const errorText = 'Error';
      
      switch (dataType) {
        case 'bitcoin-data':
          // Handle both price and dominance errors
          const priceElement = document.getElementById('bitcoin-price');
          const priceElementMobile = document.getElementById('bitcoin-price-mobile');
          const dominanceElement = document.getElementById('bitcoin-dominance');
          const dominanceElementMobile = document.getElementById('bitcoin-dominance-mobile');
          
          if (priceElement) priceElement.textContent = errorText;
          if (priceElementMobile) priceElementMobile.textContent = errorText;
          if (dominanceElement) dominanceElement.textContent = errorText;
          if (dominanceElementMobile) dominanceElementMobile.textContent = errorText;
          break;
          
        case 'hashrate':
          const hashrateElement = document.getElementById('bitcoin-hashrate');
          const hashrateElementMobile = document.getElementById('bitcoin-hashrate-mobile');
          if (hashrateElement) hashrateElement.textContent = errorText;
          if (hashrateElementMobile) hashrateElementMobile.textContent = errorText;
          break;
          
        case 'halving':
          const progressElement = document.getElementById('halving-progress');
          const progressElementMobile = document.getElementById('halving-progress-mobile');
          if (progressElement) progressElement.textContent = errorText;
          if (progressElementMobile) progressElementMobile.textContent = errorText;
          break;
      }
    }

    startUpdating() {
      this.restartUpdateTimer(true);
    }

    computeNextUpdateDelay() {
      // Determine the earliest next expiry among tracked data types
      const types = ['price', 'hashrate', 'halving'];
      const now = Date.now();
      let nextDelay = 30 * 1000; // default minimum 30s
      let foundAny = false;
      for (const type of types) {
        const cached = this.getCachedData(type);
        const effective = this.getEffectiveCacheDuration(type);
        if (!cached) {
          nextDelay = 0;
          foundAny = true;
          break;
        }
        const age = now - cached.timestamp;
        const untilExpiry = Math.max(effective - age, 0);
        if (!foundAny || untilExpiry < nextDelay) {
          nextDelay = untilExpiry;
          foundAny = true;
        }
      }
      // Put a sanity ceiling so timers don't drift too far
      const ceiling = this.isTabActive ? 15 * 60 * 1000 : 60 * 60 * 1000; // 15m active, 60m inactive
      return Math.min(Math.max(nextDelay, 15 * 1000), ceiling); // clamp to [15s, ceiling]
    }

    restartUpdateTimer(immediate = false) {
      // Clear existing timer
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      }
      if (immediate) {
        // Fire and reschedule
        this.updateStats();
      }
      const delay = this.computeNextUpdateDelay();
      this.updateTimer = setTimeout(() => {
        this.updateStats();
        // After running, schedule next
        this.restartUpdateTimer(false);
      }, delay);
    }

    // Cleanup method for when component is destroyed
    destroy() {
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      }
      if (this.visibilityHandler) {
        document.removeEventListener('visibilitychange', this.visibilityHandler);
      }
      if (this.onlineHandler) {
        window.removeEventListener('online', this.onlineHandler);
      }
      if (this.broadcastChannel) {
        try { this.broadcastChannel.close(); } catch (_) {}
      }
    }
  }

  // Singleton pattern to prevent multiple instances across SPA navigations
  function getGlobalInstance() {
    const globalRef = window;
    if (!globalRef.__bitcoinStatsInstance) {
      globalRef.__bitcoinStatsInstance = new BitcoinStatsWidget();
    } else {
      // Rebind to freshly mounted DOM on navigation
      const instance = globalRef.__bitcoinStatsInstance;
      instance.isTabActive = !document.hidden;
      instance.updateUIFromCache();
      instance.restartUpdateTimer(true);
    }
    return globalRef.__bitcoinStatsInstance;
  }

  function initializeBitcoinStats() {
    return getGlobalInstance();
  }

  // Initialize the widget when the page loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBitcoinStats);
  } else {
    initializeBitcoinStats();
  }

  // Handle Astro View Transitions lifecycle
  document.addEventListener('astro:page-load', () => {
    requestAnimationFrame(() => getGlobalInstance());
  });
  document.addEventListener('astro:after-swap', () => {
    requestAnimationFrame(() => getGlobalInstance());
  });
  // Keep the singleton alive across SPA navigations; only destroy on full unload
  // document.addEventListener('astro:before-swap', () => {});

  // Clean up on full page unload
  window.addEventListener('beforeunload', () => {
    const globalRef = window;
    if (globalRef.__bitcoinStatsInstance) {
      globalRef.__bitcoinStatsInstance.destroy();
    }
  });
</script>

<style>
  .bitcoin-stats-widget {
    animation: fadeInUp 0.8s ease-out;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .price-change-indicator,
  .price-change-indicator-mobile {
    font-weight: 600;
  }
</style>