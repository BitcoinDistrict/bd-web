name: Deploy to Production

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README*.md'
      - 'docs/**'
      - '.cursor/**'
  workflow_dispatch:
    inputs:
      force_infrastructure:
        description: 'Force infrastructure update (run all Ansible roles)'
        required: false
        default: false
        type: boolean
      skip_infrastructure:
        description: 'Skip infrastructure updates'
        required: false
        default: false
        type: boolean

env:
  DEPLOY_USER: deploy
  DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
  DEPLOY_PATH: /home/deploy/bd-web

jobs:
  # Separate job for infrastructure changes (Ansible)
  infrastructure:
    name: Apply Infrastructure Changes
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      changed: ${{ steps.detect_changes.outputs.changed }}
      roles: ${{ steps.detect_changes.outputs.roles }}
    if: |
      (github.event_name == 'workflow_dispatch' && !inputs.skip_infrastructure) ||
      (github.event_name == 'push' &&
       !contains(github.event.head_commit.message, '[skip ansible]') &&
       !contains(github.event.head_commit.message, '[skip infrastructure]'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect Ansible changes
        id: detect_changes
        run: |
          # If manually triggered with force_infrastructure, run all roles
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ inputs.force_infrastructure }}" == "true" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "roles=all" >> $GITHUB_OUTPUT
            echo "üîß Manual trigger with force_infrastructure - will run all roles"
            exit 0
          fi
          
          # Check if this is the first commit (no parent) or if ansible files changed
          if [ "$(git rev-list --count HEAD)" -eq 1 ]; then
            # First commit - check if ansible directory exists
            if [ -d "ansible" ] && [ "$(find ansible -type f | wc -l)" -gt 0 ]; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "roles=all" >> $GITHUB_OUTPUT
              echo "üìã First commit with Ansible files - will run all roles"
            else
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "roles=" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  No Ansible files in first commit"
            fi
          else
            # Check if ansible files changed compared to previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep "^ansible/" || echo "")
            if [ -n "$CHANGED_FILES" ]; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "üìã Ansible files changed:"
              echo "$CHANGED_FILES" | sed 's/^/  - /'
              
              # Determine which roles changed
              ROLES=""
              if echo "$CHANGED_FILES" | grep -qE "^ansible/playbooks/|^ansible/group_vars/|^ansible/inventory/"; then
                ROLES="all"
              else
                for role in common deploy-user docker security caddy; do
                  if echo "$CHANGED_FILES" | grep -q "^ansible/roles/$role/"; then
                    ROLES="${ROLES}${role},"
                  fi
                done
                # Also check group_vars for deploy-user related changes
                if echo "$CHANGED_FILES" | grep -q "ansible/group_vars.*rss_import\|ansible/group_vars.*app_user\|ansible/group_vars.*app_dir"; then
                  ROLES="${ROLES}deploy-user,"
                fi
                ROLES=$(echo "$ROLES" | sed 's/,$//')
                if [ -z "$ROLES" ]; then
                  ROLES="all"
                fi
              fi
              echo "roles=$ROLES" >> $GITHUB_OUTPUT
            else
              # For manual triggers without force, still check if we should run
              if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
                echo "changed=true" >> $GITHUB_OUTPUT
                echo "roles=all" >> $GITHUB_OUTPUT
                echo "üîß Manual trigger detected - will run all roles to ensure infrastructure is up to date"
              else
                echo "changed=false" >> $GITHUB_OUTPUT
                echo "roles=" >> $GITHUB_OUTPUT
                echo "‚ÑπÔ∏è  No Ansible changes detected"
              fi
            fi
          fi

      - name: Configure SSH for Infrastructure (Root Access)
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY_ROOT }}" > ~/.ssh/root_key
          chmod 600 ~/.ssh/root_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          
          # SSH config for Ansible - use root for infrastructure changes
          cat >> ~/.ssh/config << EOF
          Host ${{ secrets.PRODUCTION_HOST }}
            HostName ${{ secrets.PRODUCTION_HOST }}
            User root
            IdentityFile ~/.ssh/root_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Cache Ansible installation
        if: steps.detect_changes.outputs.changed == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.local/lib/python3.*/site-packages/ansible*
          key: ansible-${{ runner.os }}-v1
          restore-keys: |
            ansible-${{ runner.os }}-

      - name: Install Ansible
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install ansible ansible-lint

      - name: Validate Ansible syntax
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          cd ansible
          echo "üîç Validating Ansible syntax..."
          ansible-playbook --syntax-check -i inventory/production.yml playbooks/initial-setup.yml || {
            echo "‚ùå Ansible syntax validation failed!"
            exit 1
          }
          echo "‚úÖ Ansible syntax is valid"

      - name: Run Ansible in check mode (dry-run)
        if: steps.detect_changes.outputs.changed == 'true'
        env:
          BD_WEB_HOST: ${{ secrets.PRODUCTION_HOST }}
          ANSIBLE_HOST_KEY_CHECKING: False
          DEPLOY_SSH_PUBLIC_KEY: ${{ secrets.PRODUCTION_SSH_PUBLIC_KEY_DEPLOY }}
        run: |
          cd ansible
          echo "üîç Running Ansible in check mode (dry-run)..."
          
          ROLES="${{ steps.detect_changes.outputs.roles }}"
          if [ "$ROLES" = "all" ]; then
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --become \
              --check \
              --diff \
              -v
          else
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --tags "$ROLES" \
              --become \
              --check \
              --diff \
              -v
          fi
          echo "‚úÖ Check mode completed - no errors detected"

      - name: Apply Ansible changes
        if: steps.detect_changes.outputs.changed == 'true'
        env:
          BD_WEB_HOST: ${{ secrets.PRODUCTION_HOST }}
          ANSIBLE_HOST_KEY_CHECKING: False
          DEPLOY_SSH_PUBLIC_KEY: ${{ secrets.PRODUCTION_SSH_PUBLIC_KEY_DEPLOY }}
        run: |
          cd ansible
          echo "üöÄ Applying Ansible changes..."
          
          ROLES="${{ steps.detect_changes.outputs.roles }}"
          if [ "$ROLES" = "all" ]; then
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --become \
              -v
          else
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --tags "$ROLES" \
              --become \
              -v
          fi
          echo "‚úÖ Ansible changes applied successfully"

      - name: Verify infrastructure changes
        if: steps.detect_changes.outputs.changed == 'true' && contains(steps.detect_changes.outputs.roles, 'common')
        run: |
          echo "üîç Verifying Node.js and npm installation..."
          ssh -i ~/.ssh/root_key -o StrictHostKeyChecking=no \
            root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          
          echo "Checking Node.js version..."
          node --version || {
            echo "‚ùå Node.js not found!"
            exit 1
          }
          
          echo "Checking npm version..."
          npm --version || {
            echo "‚ùå npm not found!"
            exit 1
          }
          
          echo "‚úÖ Node.js and npm are installed correctly"
          ENDSSH

      - name: Upload Ansible logs
        if: always() && steps.detect_changes.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ansible-logs-${{ github.sha }}
          path: |
            ~/.ansible/
          retention-days: 7
          if-no-files-found: ignore

      - name: Clean up SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/root_key ~/.ssh/config

  # Application deployment job
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [infrastructure]
    if: |
      !contains(github.event.head_commit.message, '[skip deploy]') &&
      !contains(github.event.head_commit.message, '[skip application]')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure SSH for Deployment (Deploy User)
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY_DEPLOY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          
          # SSH config for deployment operations
          cat >> ~/.ssh/config << EOF
          Host ${{ secrets.PRODUCTION_HOST }}
            HostName ${{ secrets.PRODUCTION_HOST }}
            User deploy
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Create production .env file
        run: |
          cat > .env << EOF
          # PostgreSQL Configuration
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          
          # Directus Configuration
          DIRECTUS_KEY=${{ secrets.DIRECTUS_KEY }}
          DIRECTUS_SECRET=${{ secrets.DIRECTUS_SECRET }}
          DIRECTUS_ADMIN_EMAIL=${{ secrets.DIRECTUS_ADMIN_EMAIL }}
          DIRECTUS_ADMIN_PASSWORD=${{ secrets.DIRECTUS_ADMIN_PASSWORD }}
          
          # Public URLs
          PUBLIC_DIRECTUS_URL=https://admin.bitcoindistrict.org
          
          # CMS Enable/Disable
          PUBLIC_CMS_ENABLED=${{ secrets.PUBLIC_CMS_ENABLED || 'true' }}
          
          # Directus Tokens
          DIRECTUS_STATIC_TOKEN=${{ secrets.DIRECTUS_STATIC_TOKEN }}
          DIRECTUS_EVENTS_TOKEN=${{ secrets.DIRECTUS_EVENTS_TOKEN }}
          EOF

      - name: Sync files to server
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude '.git' \
            --exclude '.github' \
            --exclude 'node_modules' \
            --exclude '.env' \
            --exclude 'directus/data' \
            --exclude 'directus/extensions' \
            --exclude 'directus/uploads' \
            --exclude '.cursor' \
            --exclude 'site/node_modules' \
            --exclude 'site/dist' \
            ./ ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/

      - name: Copy .env file to server
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            .env ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/.env

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          echo "Pulling latest Docker images..."
          docker compose -f docker-compose.prod.yml pull
          
          echo "Building and starting containers (including Caddy)..."
          docker compose -f docker-compose.prod.yml up -d --build --force-recreate --remove-orphans
          
          echo "Waiting for services to be healthy..."
          sleep 15
          
          echo "Checking container status..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "Checking Caddy logs for certificate provisioning..."
          docker compose -f docker-compose.prod.yml logs caddy --tail=50
          ENDSSH

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          echo "=== Container Status ==="
          docker compose -f docker-compose.prod.yml ps
          
          echo ""
          echo "=== Caddy Container Logs ==="
          docker compose -f docker-compose.prod.yml logs caddy --tail=30
          
          echo ""
          echo "=== Application Logs ==="
          docker compose -f docker-compose.prod.yml logs astro directus --tail=20
          ENDSSH

      - name: Health check
        run: |
          echo "Waiting for Caddy to obtain certificates and start serving..."
          sleep 30
          
          MAX_RETRIES=6
          RETRY_DELAY=10
          
          # Function to check HTTP status (accepts 2xx and 3xx as success)
          # For Directus health endpoint, also validates JSON response
          check_url() {
            local url=$1
            local name=$2
            local response=$(curl -L -s -w "\n%{http_code}" --max-time 10 --connect-timeout 5 "$url" 2>/dev/null || echo -e "\n000")
            local body=$(echo "$response" | head -n -1)
            local status_code=$(echo "$response" | tail -n 1)
            
            if [ "$status_code" = "000" ]; then
              echo "‚ö†Ô∏è  $name: Connection failed or timeout"
              return 1
            elif [ "$status_code" -ge 200 ] && [ "$status_code" -lt 400 ]; then
              # For Directus health endpoint, validate JSON response
              if [[ "$url" == *"/server/health"* ]]; then
                if echo "$body" | grep -q '"status":"ok"\|"status":"healthy"'; then
                  echo "‚úÖ $name is healthy (HTTP $status_code)"
                elif echo "$body" | grep -qE '^\s*\{.*\}' && command -v jq >/dev/null 2>&1; then
                  # If jq is available, validate JSON structure
                  if echo "$body" | jq . >/dev/null 2>&1; then
                    echo "‚úÖ $name is responding (HTTP $status_code, valid JSON)"
                  else
                    echo "‚úÖ $name is responding (HTTP $status_code)"
                  fi
                else
                  echo "‚úÖ $name is responding (HTTP $status_code)"
                fi
              else
                echo "‚úÖ $name is responding (HTTP $status_code)"
              fi
              return 0
            else
              echo "‚ö†Ô∏è  $name returned HTTP $status_code"
              return 1
            fi
          }
          
          # Check main site
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Testing main site..."
            if check_url "https://staging.bitcoindistrict.org/" "Main site"; then
              break
            else
              if [ $i -eq $MAX_RETRIES ]; then
                echo "‚ùå Main site failed after $MAX_RETRIES attempts"
                exit 1
              fi
              echo "‚ö†Ô∏è  Main site not ready, waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          # Check admin panel (using Directus health endpoint)
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Testing admin panel..."
            if check_url "https://admin.bitcoindistrict.org/server/health" "Admin panel"; then
              break
            else
              if [ $i -eq $MAX_RETRIES ]; then
                echo "‚ùå Admin panel failed after $MAX_RETRIES attempts"
                exit 1
              fi
              echo "‚ö†Ô∏è  Admin panel not ready, waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

      - name: Clean up SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key ~/.ssh/config

      - name: Deployment summary
        if: success()
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Main site: https://staging.bitcoindistrict.org"
          echo "‚öôÔ∏è  Admin panel: https://admin.bitcoindistrict.org"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Deployed by: ${{ github.actor }}"
          if [ "${{ needs.infrastructure.outputs.changed }}" == "true" ]; then
            echo "üîß Infrastructure changes were applied (roles: ${{ needs.infrastructure.outputs.roles }})"
          elif [ -n "${{ needs.infrastructure.outputs.changed }}" ]; then
            echo "‚ÑπÔ∏è  No infrastructure changes detected"
          fi

      - name: Deployment failed
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Check the logs above for details."
          echo "You can manually check the server with:"
          echo "ssh deploy@${{ secrets.PRODUCTION_HOST }}"
          exit 1
