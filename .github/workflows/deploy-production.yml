name: Deploy to Production

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README*.md'
      - 'docs/**'
      - '.cursor/**'
  workflow_dispatch:
    inputs:
      force_infrastructure:
        description: 'Force infrastructure update (run all Ansible roles)'
        required: false
        default: false
        type: boolean
      skip_infrastructure:
        description: 'Skip infrastructure updates'
        required: false
        default: false
        type: boolean

env:
  DEPLOY_USER: deploy
  DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
  DEPLOY_PATH: /home/deploy/bd-web

jobs:
  # Separate job for infrastructure changes (Ansible)
  infrastructure:
    name: Apply Infrastructure Changes
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      changed: ${{ steps.detect_changes.outputs.changed }}
      roles: ${{ steps.detect_changes.outputs.roles }}
    if: |
      (github.event_name == 'workflow_dispatch' && !inputs.skip_infrastructure) ||
      (github.event_name == 'push' &&
       !contains(github.event.head_commit.message, '[skip ansible]') &&
       !contains(github.event.head_commit.message, '[skip infrastructure]'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect Ansible changes
        id: detect_changes
        run: |
          # If manually triggered with force_infrastructure, run all roles
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ inputs.force_infrastructure }}" == "true" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "roles=all" >> $GITHUB_OUTPUT
            echo "ðŸ”§ Manual trigger with force_infrastructure - will run all roles"
            exit 0
          fi
          
          # Check if this is the first commit (no parent) or if ansible files changed
          if [ "$(git rev-list --count HEAD)" -eq 1 ]; then
            # First commit - check if ansible directory exists
            if [ -d "ansible" ] && [ "$(find ansible -type f | wc -l)" -gt 0 ]; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "roles=all" >> $GITHUB_OUTPUT
              echo "ðŸ“‹ First commit with Ansible files - will run all roles"
            else
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "roles=" >> $GITHUB_OUTPUT
              echo "â„¹ï¸  No Ansible files in first commit"
            fi
          else
            # Check if ansible files changed compared to previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep "^ansible/" || echo "")
            if [ -n "$CHANGED_FILES" ]; then
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "ðŸ“‹ Ansible files changed:"
              echo "$CHANGED_FILES" | sed 's/^/  - /'
              
              # Determine which roles changed
              ROLES=""
              if echo "$CHANGED_FILES" | grep -qE "^ansible/playbooks/|^ansible/group_vars/|^ansible/inventory/"; then
                ROLES="all"
              else
                for role in common deploy-user docker security caddy; do
                  if echo "$CHANGED_FILES" | grep -q "^ansible/roles/$role/"; then
                    ROLES="${ROLES}${role},"
                  fi
                done
                # Also check group_vars for deploy-user related changes
                if echo "$CHANGED_FILES" | grep -q "ansible/group_vars.*rss_import\|ansible/group_vars.*app_user\|ansible/group_vars.*app_dir"; then
                  ROLES="${ROLES}deploy-user,"
                fi
                ROLES=$(echo "$ROLES" | sed 's/,$//')
                if [ -z "$ROLES" ]; then
                  ROLES="all"
                fi
              fi
              echo "roles=$ROLES" >> $GITHUB_OUTPUT
            else
              # For manual triggers without force, still check if we should run
              if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
                echo "changed=true" >> $GITHUB_OUTPUT
                echo "roles=all" >> $GITHUB_OUTPUT
                echo "ðŸ”§ Manual trigger detected - will run all roles to ensure infrastructure is up to date"
              else
                echo "changed=false" >> $GITHUB_OUTPUT
                echo "roles=" >> $GITHUB_OUTPUT
                echo "â„¹ï¸  No Ansible changes detected"
              fi
            fi
          fi

      - name: Configure SSH
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          
          # SSH config for Ansible
          cat >> ~/.ssh/config << EOF
          Host ${{ secrets.PRODUCTION_HOST }}
            HostName ${{ secrets.PRODUCTION_HOST }}
            User deploy
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

      - name: Cache Ansible installation
        if: steps.detect_changes.outputs.changed == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.local/lib/python3.*/site-packages/ansible*
          key: ansible-${{ runner.os }}-v1
          restore-keys: |
            ansible-${{ runner.os }}-

      - name: Install Ansible
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install ansible ansible-lint

      - name: Validate Ansible syntax
        if: steps.detect_changes.outputs.changed == 'true'
        run: |
          cd ansible
          echo "ðŸ” Validating Ansible syntax..."
          ansible-playbook --syntax-check -i inventory/production.yml playbooks/initial-setup.yml || {
            echo "âŒ Ansible syntax validation failed!"
            exit 1
          }
          echo "âœ… Ansible syntax is valid"

      - name: Run Ansible in check mode (dry-run)
        if: steps.detect_changes.outputs.changed == 'true'
        env:
          BD_WEB_HOST: ${{ secrets.PRODUCTION_HOST }}
          ANSIBLE_HOST_KEY_CHECKING: False
        run: |
          cd ansible
          echo "ðŸ” Running Ansible in check mode (dry-run)..."
          
          ROLES="${{ steps.detect_changes.outputs.roles }}"
          if [ "$ROLES" = "all" ]; then
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              -e "ansible_user=deploy" \
              --become \
              --check \
              --diff \
              -v
          else
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --tags "$ROLES" \
              -e "ansible_user=deploy" \
              --become \
              --check \
              --diff \
              -v
          fi
          echo "âœ… Check mode completed - no errors detected"

      - name: Apply Ansible changes
        if: steps.detect_changes.outputs.changed == 'true'
        env:
          BD_WEB_HOST: ${{ secrets.PRODUCTION_HOST }}
          ANSIBLE_HOST_KEY_CHECKING: False
        run: |
          cd ansible
          echo "ðŸš€ Applying Ansible changes..."
          
          ROLES="${{ steps.detect_changes.outputs.roles }}"
          if [ "$ROLES" = "all" ]; then
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              -e "ansible_user=deploy" \
              --become \
              -v
          else
            ansible-playbook -i inventory/production.yml playbooks/initial-setup.yml \
              --tags "$ROLES" \
              -e "ansible_user=deploy" \
              --become \
              -v
          fi
          echo "âœ… Ansible changes applied successfully"

      - name: Verify infrastructure changes
        if: steps.detect_changes.outputs.changed == 'true' && contains(steps.detect_changes.outputs.roles, 'common')
        run: |
          echo "ðŸ” Verifying Node.js and npm installation..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          
          echo "Checking Node.js version..."
          node --version || {
            echo "âŒ Node.js not found!"
            exit 1
          }
          
          echo "Checking npm version..."
          npm --version || {
            echo "âŒ npm not found!"
            exit 1
          }
          
          echo "âœ… Node.js and npm are installed correctly"
          ENDSSH

      - name: Upload Ansible logs
        if: always() && steps.detect_changes.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ansible-logs-${{ github.sha }}
          path: |
            ~/.ansible/
          retention-days: 7
          if-no-files-found: ignore

      - name: Clean up SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key ~/.ssh/config

  # Application deployment job
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [infrastructure]
    if: |
      !contains(github.event.head_commit.message, '[skip deploy]') &&
      !contains(github.event.head_commit.message, '[skip application]')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Create production .env file
        run: |
          cat > .env << EOF
          # PostgreSQL Configuration
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          
          # Directus Configuration
          DIRECTUS_KEY=${{ secrets.DIRECTUS_KEY }}
          DIRECTUS_SECRET=${{ secrets.DIRECTUS_SECRET }}
          DIRECTUS_ADMIN_EMAIL=${{ secrets.DIRECTUS_ADMIN_EMAIL }}
          DIRECTUS_ADMIN_PASSWORD=${{ secrets.DIRECTUS_ADMIN_PASSWORD }}
          
          # Public URLs
          PUBLIC_DIRECTUS_URL=https://admin.bitcoindistrict.org
          
          # CMS Enable/Disable
          PUBLIC_CMS_ENABLED=${{ secrets.PUBLIC_CMS_ENABLED || 'true' }}
          
          # Directus Tokens
          DIRECTUS_STATIC_TOKEN=${{ secrets.DIRECTUS_STATIC_TOKEN }}
          DIRECTUS_EVENTS_TOKEN=${{ secrets.DIRECTUS_EVENTS_TOKEN }}
          EOF

      - name: Sync files to server
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude '.git' \
            --exclude '.github' \
            --exclude 'node_modules' \
            --exclude '.env' \
            --exclude 'directus/data' \
            --exclude 'directus/extensions' \
            --exclude 'directus/uploads' \
            --exclude '.cursor' \
            --exclude 'site/node_modules' \
            --exclude 'site/dist' \
            ./ ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/

      - name: Copy .env file to server
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            .env ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/.env


      - name: Validate and deploy Caddyfile
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          echo "Ensuring Caddy log directory exists..."
          sudo mkdir -p /var/log/caddy
          sudo chown caddy:caddy /var/log/caddy
          sudo chmod 755 /var/log/caddy
          
          echo "Validating Caddyfile syntax..."
          sudo caddy validate --config ./Caddyfile || {
            echo "âŒ Caddyfile validation failed!"
            exit 1
          }
          
          echo "Copying validated Caddyfile to system location..."
          sudo cp ./Caddyfile /etc/caddy/Caddyfile
          sudo chown root:root /etc/caddy/Caddyfile
          sudo chmod 644 /etc/caddy/Caddyfile
          ENDSSH

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          echo "Pulling latest Docker images..."
          docker compose -f docker-compose.prod.yml pull
          
          echo "Building and starting containers (forcing recreate to pick up new env vars)..."
          docker compose -f docker-compose.prod.yml up -d --build --force-recreate --remove-orphans
          
          echo "Waiting for services to be healthy..."
          sleep 10
          
          echo "Checking container status..."
          docker compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Reload Caddy
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          
          echo "Reloading Caddy service..."
          if sudo systemctl reload caddy; then
            echo "âœ… Caddy reloaded successfully"
          elif sudo systemctl restart caddy; then
            echo "âœ… Caddy restarted successfully"
          else
            echo "âŒ Caddy reload/restart failed"
            echo ""
            echo "=== Caddy Status ==="
            sudo systemctl status caddy --no-pager || true
            echo ""
            echo "=== Caddy Logs ==="
            sudo journalctl -xeu caddy.service --no-pager -n 50 || true
            exit 1
          fi
          ENDSSH

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          echo "=== Container Status ==="
          docker compose -f docker-compose.prod.yml ps
          
          echo ""
          echo "=== Caddy Status ==="
          sudo systemctl status caddy --no-pager || true
          
          echo ""
          echo "=== Recent Logs ==="
          docker compose -f docker-compose.prod.yml logs --tail=20
          ENDSSH

      - name: Health check
        run: |
          echo "Waiting for services to be ready..."
          sleep 15
          
          echo "Testing main site..."
          curl -f -k https://staging.bitcoindistrict.org/ || echo "Main site not responding yet"
          
          echo "Testing admin panel..."
          curl -f -k https://admin.bitcoindistrict.org || echo "Admin panel not responding yet"

      - name: Clean up SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key ~/.ssh/config

      - name: Deployment summary
        if: success()
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Main site: https://staging.bitcoindistrict.org"
          echo "âš™ï¸  Admin panel: https://admin.bitcoindistrict.org"
          echo "ðŸ“ Commit: ${{ github.sha }}"
          echo "ðŸ‘¤ Deployed by: ${{ github.actor }}"
          if [ "${{ needs.infrastructure.outputs.changed }}" == "true" ]; then
            echo "ðŸ”§ Infrastructure changes were applied (roles: ${{ needs.infrastructure.outputs.roles }})"
          elif [ -n "${{ needs.infrastructure.outputs.changed }}" ]; then
            echo "â„¹ï¸  No infrastructure changes detected"
          fi

      - name: Deployment failed
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "Check the logs above for details."
          echo "You can manually check the server with:"
          echo "ssh deploy@${{ secrets.PRODUCTION_HOST }}"
          exit 1
